use digest::{core_api::XofReaderCore, crypto_common::BlockSizes};
use hybrid_array::Array;
use inout::InOutBuf;

pub struct XofReaderCoreWrapperXor<T>
where
    T: XofReaderCore,
{
    core: T,
    buffer: XorBuffer<T::BlockSize>,
}

impl<T> XofReaderCoreWrapperXor<T>
where
    T: XofReaderCore,
{
    pub fn from_core(core: T) -> Self {
        Self {
            core,
            buffer: XorBuffer::default(),
        }
    }

    #[inline]
    pub fn set_pos(&mut self, p: usize) {
        self.buffer.set_pos(p);
    }

    #[inline]
    pub fn xor(&mut self, buffer: InOutBuf<'_, '_, u8>) {
        let Self { core, buffer: buf } = self;
        buf.xor(buffer, || core.read_block());
    }
}

/// Like [`block_buffer::ReadBuffer`] but applys XOR.
#[derive(Default)]
pub(crate) struct XorBuffer<B: BlockSizes> {
    // The first byte of the block is used as position.
    buffer: Array<u8, B>,
}

impl<B: BlockSizes> XorBuffer<B> {
    #[inline]
    pub fn set_pos(&mut self, p: usize) {
        assert!(p < B::USIZE);
        self.buffer[0] = p as u8;
    }

    /// Write remaining data inside buffer into `data`, fill remaining space
    /// in `data` with blocks generated by `gen_block`, and save leftover data
    /// from the last generated block into buffer for future use.
    #[inline]
    pub fn xor(
        &mut self,
        mut data: InOutBuf<'_, '_, u8>,
        mut gen_block: impl FnMut() -> Array<u8, B>,
    ) {
        let pos = self.buffer[0] as usize;
        let r = B::USIZE - pos;
        let n = data.len();

        if r != 0 {
            if n < r {
                // double slicing allows to remove panic branches
                data.xor_in2out(&self.buffer[pos..][..n]);
                self.buffer[0] = (pos + n) as u8;
                return;
            }
            let (mut left, right) = data.split_at(r);
            data = right;
            left.xor_in2out(&self.buffer[pos..]);
        }

        let (blocks, mut leftover) = data.into_chunks::<B>();
        for mut block in blocks {
            block.xor_in2out(&gen_block());
        }

        let n = leftover.len();
        if n != 0 {
            let block = gen_block();
            leftover.xor_in2out(&block[..n]);
            self.buffer = block;
            self.buffer[0] = n as u8;
        } else {
            self.buffer[0] = B::U8;
        }
    }
}
